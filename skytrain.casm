CoreASM skytrain

use Standard
use BasicASM
use Time
use Math

universe Agents = {WestTrackController, EastTrackController, WestDoorController, EastDoorController, observer, environment}

enum Tracks = {west, east}
enum TrackStatus = {empty, arriving, stopped, prepLeaving, leaving}
enum DoorStatus = {open, closing, closed, opening}
enum DoorSensorStatus = {clear, blocked}

function trackStatus : Tracks -> TrackStatus
function doorStatus : Tracks -> DoorStatus
function doorSensor : Tracks -> DoorSensorStatus
function deadline : Tracks -> TIME
function businessFactor : Tracks -> NUMBER

init InitRule

rule InitRule = {
	doorOpeningT := 2000
	doorStayOpenT := 10000
	doorClosingT := 2000
	doorCloseCheckT := 2000
	doorInterferenceT := 1000
	trainLeaveT := 10000
	startTime := now
	forall t in Tracks do {
		trackStatus(t) := empty
		doorStatus(t) := closed
		doorSensor(t) := clear
		deadline(t) := infinity
		businessFactor(t) := 1.0
	}
	program(WestTrackController) := @WestTrackControl
	program(WestDoorController) := @WestDoorControl
	program(EastTrackController) := @EastTrackControl
	program(EastDoorController) := @EastDoorControl
	program(environment) := @Station
	program(observer) := @ObserverProgram
	program(self) := undef
}

rule WestTrackControl = {
	handleArrived(west)
	handleLeaving(west)
}

rule handleArrived(t) = 
	if trackStatus(t) = stopped and deadline(t) = infinity then {
		deadline(t) := now + doorOpeningT
		doorStatus(t) := opening
	}

rule handleLeaving(t) = {
	if trackStatus(t) = stopped and doorStatus(t) = closed and now >= deadline(t) then {
		deadline(t) := now + doorCloseCheckT
		trackStatus(t) := prepLeaving
	}
	if trackStatus(t) = prepLeaving and now >= deadline(t) then {
		trackStatus(t) := leaving
		deadline(t) := now + trainLeaveT
	}
	if trackStatus(t) = leaving and now >= deadline(t) then {
		trackStatus(t) := empty
		deadline(t) := infinity
	}
}
		
rule WestDoorControl = {
	handleOpening(west)
	handleClosing(west)	
}

rule handleOpening(t) = 
	if trackStatus(t) = stopped and doorStatus(t) = opening and now >= deadline(t) then {
		doorStatus(t) := open
		deadline(t) := now + doorStayOpenT
		businessFactor(t) := random 
	}

rule handleClosing(t) = {
	if trackStatus(t) = stopped and doorStatus(t) = open and now >= deadline(t) and doorSensor(t) = clear then {
		doorStatus(t) := closing
		deadline(t) := now + doorClosingT
	}
	if trackStatus(t) = stopped and doorStatus(t) = closing and doorSensor(t) = blocked then {
		doorStatus(t) := open
		deadline(t) := now + doorInterferenceT
	}
	if trackStatus(t) = stopped and doorStatus(t) = closing and doorSensor(t) = clear and now >= deadline(t) then
		doorStatus(t) := closed
}

rule Station = {
	if random < 0.05 and trackStatus(west) = empty then {
		trackStatus(west) := stopped
	}
	if doorStatus(west) = open or doorStatus(west) = closing then {
		businessFactor(west) := businessFactor(west)*0.98
		if random < businessFactor(west) then
			doorSensor(west) := blocked
		else
			doorSensor(west) := clear
	}
}

rule ObserverProgram =
	seqblock
		print "Time: " + ((now - startTime) / 1000) + " seconds"
		print "Track west is " + trackStatus(west)
		print "West Doors are " + doorStatus(west)
		if doorStatus(west) = open or doorStatus(west) = closing then
			print "Sensors are " + doorSensor(west)
			print "businessFactor: " + businessFactor(west)
		print ""
	endseqblock